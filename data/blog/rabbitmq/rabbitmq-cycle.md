
# rabbitmq消息模型，一条消息的一生

![](/images/rabbit4.jpg)

## 图解
- 最左边的两个 ClientA/ClientA 圈圈是生产者，由你们用顺手的编程语言自己写
- 最右边三个 Client 圈圈是消费者，亦是你们自己编写
- 红色虚线框里面的部分就是 rabbitmq 服务器啦
- 红色虚线框里面的 Exchange1/Exchange2 就是交换机
- 红色虚线框里面的 Queue1/Queue2 就是队列
- 队列跟交换机的关系，多对多

## 知识回忆

前文说到，rabbitmq 是`消息代理服务器`，它们不生产消息，只是网络的搬运工。结合上面的图解，红色虚线框部分就是这个`消息代理服务器`，而最左边的生产者才是产生消息的地方。

## 创建交换机和队列
- 生产者消费者都可以创建交换机和队列
- 而我们写的程序，通常是生产者消费者都尝试创建交换机和队列
- 一般情况下，都是由消费者真正创建交换机和队列的

## 根据上面的前提，我们来发送一遍消息

> 假设我们已经使用 php 编写好了生产者和消费者；假设忽略连接RabbitMQ、获取信道

### 启动消费者
- 消费者声明交换和队列
- 通过路由键绑定交换和队列
- 消费者订阅这个队列

### 启动生产者
- 生产者创建消息
- 生产者把消息发给交换机
- 交换机把消息投递给匹配的队列

### 消费者收到队列推送过来的消息
- 消费者确认收到消息
- 队列把这条消息移除

## 消息的投递
细心的童鞋可能会发现，上文说的是 “投递给匹配的队列” 而不是 “投递给绑定的队列”。没错，绑定了不一定能接收到投递，如果是直连交换机，还需要看路由键对不对

### 像邮箱一样，为离线消费者存储消息
- 在队列正常存在的情况下，如果消费者离线了，消息会暂存在队列里

### 隐去了消息的接受方和发送方
- 消息由两部分组成：标签和有效载荷
- 有效载荷就是消息的内容，类比信件，就是信封里面的部分
- 标签用来描述消息，说明消息的去处
- 发后即忘，队列收到消息之后是不知道消息来自哪里的

### 如果没有匹配的队列，交换机会把消息丢弃
- 交换机只管把消息往后抛，有没有队列接收它不管

### 队列的每条消息只会发给一个订阅的消费者
- 交换机却有可能把消息投递给符合条件的多个队列

### 消费者没有ask就断开连接
- 队列会认为此消费者没有收到消息，继而把消息发送给下一个消费者，如果不存在下一个消费者，则暂存

### 消费者程序耗时很长，尚未ask；或者程序bug，忘记 ask
- 这种情况下，队列可能会给消费者尝试再推送两条消息，之后就不会推更多的消息了，直到它正确`ask`之后
